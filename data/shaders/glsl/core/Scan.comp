#version 450
#extension GL_KHR_shader_subgroup_arithmetic : enable

#define T int
#define DataType T
#define SCAN_TYPE_EXCLUSIVE 0
#define SCAN_TYPE_INCLUSIVE 1

layout(std430, binding = 0) buffer Input
{
   DataType inputs[];
};

layout(std430, binding = 1) buffer Output
{
   DataType outputs[];
};

layout(std430, binding = 2) buffer NextLevel
{
   DataType next_level[];
};

layout(push_constant) uniform PushConsts
{
  int n;
  int ScanType;
} consts;


layout (local_size_x = 256) in;
layout (constant_id = 2) const int sumSubGroupSize = 64;


shared DataType sdata[sumSubGroupSize];

void main()
{
    DataType sum = 0;
	DataType inputValue = 0;
    if (gl_GlobalInvocationID.x < consts.n)
    {
        sum = inputs[gl_GlobalInvocationID.x];
		inputValue = sum;
    }

	sum = subgroupInclusiveAdd(sum);

    if (gl_SubgroupInvocationID == gl_SubgroupSize - 1)
    {
        sdata[gl_SubgroupID] = sum;
    }
	
    memoryBarrierShared();
    barrier();

    if (gl_SubgroupID == 0)
    {
        DataType warpSum = gl_SubgroupInvocationID < gl_NumSubgroups ? sdata[gl_SubgroupInvocationID] : 0;
        warpSum = subgroupInclusiveAdd(warpSum);
        sdata[gl_SubgroupInvocationID] = warpSum;
    }

    memoryBarrierShared();
    barrier();

    DataType blockSum = 0;
    if (gl_SubgroupID > 0)
    {
        blockSum = sdata[gl_SubgroupID - 1];
    }

    sum += blockSum;

    if (gl_GlobalInvocationID.x < consts.n)
    {
        if(consts.ScanType == SCAN_TYPE_EXCLUSIVE)
		    outputs[gl_GlobalInvocationID.x] = sum - inputValue;
        else
		    outputs[gl_GlobalInvocationID.x] = sum;
    }
    if (gl_LocalInvocationID.x == gl_WorkGroupSize.x - 1)
    {
        next_level[gl_WorkGroupID.x] = sum;
    }
}
